# 七种设计模式

## 1. UML 类图

### 1.1介绍

UML - Unified Modeling Language - 统一建模语言。软件工程（不仅是编程） 中的任何设计都可以用它来表述， 包含：

- 类图
- 用例图
- 对象图
- 顺序图
- 协作图
- 状态图
- 活动图
- 组件图
- 配置图

### 1.2 UML 类图的作用

- 需求指导设计， 设计指导开发
- 开发之前， 写技术方案设计文档， 并评审
- UML类图就是一个重要的工具和表达方式。 如果你和同事都熟悉 UML类图， 那会减少很多沟通成本， 不用看代码就可以知道你的代码结构， 核心属性和方法

### 1.3 单个类

#### 1.3.1三个区域

1. 类名
2. 属性
3. 方法

![](https://noteimagebuket.oss-cn-hangzhou.aliyuncs.com/typora/202508280011541.png)

示例：

![](https://noteimagebuket.oss-cn-hangzhou.aliyuncs.com/typora/202508280011924.png)

#### 1.3.2权限描述

- `+ public`
- `# protected`
- `- private`

#### 1.3.3类图的几种关系

1. 实现：实现接口
2. 泛化：继承
3. 关联：A 是 B 的一个属性
   1. 聚合 - 整体包含部分， 部分可以脱离整体单独存在
   2. 组合 - 整体包含部分， 部分不可脱离整体
   3. 依赖 - 不是属性， 函数参数、 返回值

【注意】 聚合、 组合、 依赖， 都属于关联关系， 更加细化了。 日常工作中没必要区分那么细致， 都当做关联关系即可

#### 1.3.4实现接口

注意： TS 的 interface 和 Java 的不一样， TS 有属性， 而 Java 的没有属性。 而 UML类图是依据 Java 语法而画的（没有属性区域） ， 课程里也合并到一个区域了。

![](https://noteimagebuket.oss-cn-hangzhou.aliyuncs.com/typora/202508280011991.png)

示例：（对应类图是上图所示）

```react jsx 
interface IPerson {
  name: string;
  age: number;
  sayHi(otherName: string): void;
}

class Person implements IPerson {
  name: string;
  age: number;
  constructor(name: string, age: number) {
    this.name = name;
    this.age = age;
  }
  sayHi(otherName: string) {
    alert(`Hi,${otherName}`);
  }
}
```


#### 1.3.5泛化 - 继承父类

示例代码：

对应类图：

![](https://noteimagebuket.oss-cn-hangzhou.aliyuncs.com/typora/202508280011109.png)

#### 1.3.6关联

分类：

- 单项关联
- 双向关联
- 自关联

![](https://noteimagebuket.oss-cn-hangzhou.aliyuncs.com/typora/202508280011836.png)

- **聚合**

  整体包含部分，部分可以脱离整体单独存在

  ![](https://noteimagebuket.oss-cn-hangzhou.aliyuncs.com/typora/202508280011375.png)
- **组合**

  整体包含部分，部分**不可**脱离整体

  ![](https://noteimagebuket.oss-cn-hangzhou.aliyuncs.com/typora/202508280011146.png)
- **依赖**

  不是属性，函数参数、返回值

  ![](https://noteimagebuket.oss-cn-hangzhou.aliyuncs.com/typora/202508280011127.png)

## 2. 设计原则

### 2.1五大设计原则

S O L I D 五大设计原则

- S 单一职责原则
- O 开放封闭原则
- L 李氏置换原则
- I 接口独立原则
- D 依赖导致原则

### 2.2单一职责原则

一个程序只做好一件事，如果功能过于复杂就拆分开，每个部分保持独立。

### 2.3开放封闭原则 —— 最重要

对修改封闭，对扩展开放，**这是软件设计的终极目标**。即要设计一种机制，当需求发生变化时，根据这种机制扩展代码，而不是修改原有的代码。

### 2.4李氏置换原则

子类能覆盖父类，父类能出现的地方子类就能出现 —— 前端应用较少。

### 2.5接口隔离原则

保持接口的单一独立，避免出现“胖接口”。类似于单一职责原则，只不过前者说的比较统一，后者是单独对接口的规定。JS 中没有接口，因此体现较少。

### 2.6依赖倒置原则

面向接口编程，依赖于抽象而不依赖于具体。写代码时用到具体类时，不与具体类交互，而与具体类的上层接口交互。

```typescript 
function fn(p: Student) {} // 依赖具体的类
function fn(p: IPerson) {} // 依赖接口
```


### 2.7 举例说明

以常见的 Promise 来解释一下前两个原则。

```typescript 
// 加载图片
function loadImg(src: string) { 
    const promise = new Promise((resolve, reject) => {
        const img = document.createElement('img')
        img.onload = () => { 
            resolve(img)
        }
        img.onerror = () => { 
            reject('图片加载失败')
        }
        img.src = src
    })
    return promise
}

const src = 'https://www.imooc.com/static/img/index/logo_new.png'

const result = loadImg(src)
result.then((img: HTMLImageElement) => {
    console.log('img.width', img.width)
    return img
}).then((img: HTMLImageElement) => {
    console.log('img.height', img.height)
}).catch((err) => {
    console.log(err)
})
```


- 单一职责原则：每个`then`中的逻辑只做好一件事，如果要做多个就用多个`then`
- 开放封闭原则：如果这个需求要修改，那去扩展`then`即可，现有的逻辑不用修改，即对扩展开放、对修改封闭

这里引申两点：

- 其实 S 和 O 是相符现成的，相互依赖
- 开放封闭原则的好处不止于此，从整个软件开发流程看，减少现有逻辑的更改，也会减少测试的成本

# 3. 23 种设计模式

## 3.1 从设计到模式

“设计”和“模式”两个词应该分开读，先有设计，后有模式。

- 设计：设计原则，设计思想
- 模式：前辈总结出来的固定的套路

为何需要设计？—— 因为软件规模变大，甚至是一个系统集群，需要先设计，后开发，否则就乱掉

为何需要模式？—— 可套用前人经验，降低设计和沟通的成本

## 3.2 23 种设计模式

1995 年，四位前辈出版了一本书《设计模式：可复用面向对象软件的基础》，里面总结了常用的 23 种设计模式，被后人一直沿用至今。

- 创建型模式
  - **工厂模式**（包括：工厂方法模式，抽象工厂模式，建造者模式）
  - **单例模式**
  - **原型模式**
- 结构型模式
  - 适配器模式
  - **装饰器模式**
  - **代理模式**
  - 外观模式
  - 桥接模式
  - 组合模式
  - 享元模式
- 行为型模式
  - 策略模式
  - 模板方法模式
  - **观察者模式**
  - **迭代器模式**
  - 职责连模式
  - 命令模式
  - 备忘录模式
  - 状态模式
  - 访问者模式
  - 中介者模式
  - 解释器模式

![](https://noteimagebuket.oss-cn-hangzhou.aliyuncs.com/typora/202508280012932.png)

## 3.3 前端常用的设计模式

> 这就是课程的价值，帮你节省时间，直击重点，不盲目

1995 年还没有前端，所有当时的一些设计模式，并不完全适用于现在。而且，前后端也有区别。

所以，前端最常用的设计模式，就以下几个：

- 工厂模式
- 单例模式
- 原型模式
- 装饰器模式
- 代理模式
- 观察者模式
- 迭代器模式

要结合实际应用，把它们学精、学透彻，要明白 JS 是如何体现这些设计模式的。 让你学完了就忘不了（不常用的，学完就忘）

# 4.工厂模式

> 注意：遇到 `new class` 时，考虑工厂模式。

创建对象的一种方式。不用每次都亲自创建对象，而是通过一个既定的“工厂”来生产对象。

## 4.1示例

现在你要得到一个汉堡，你是跟服务员要（买）一个，还是自己动手做一个？这个问题，服务员就是工厂方法，而动手做一个其实就是`new A()`。
另外从快餐店考虑，你想要提供一个汉堡，是让服务员（工厂方法）做出来（`new A()`）给客户，还是让客户自己做一个汉堡？

从这个示例很容易理解工厂模式的用意，**所有的设计模式都是很讲道理的，很容易理解**

## 4.2伪代码

OOP 中，默认创建对象一般是 `new class` ，但一些情况下用 `new class` 会很不方便。

```javascript 
// 伪代码
let f1
class Foo {}

if (a) {
    f1 = Foo(x)
}
if (b) {
    f2 = Foo(x, y)
}
```


此时就需要一个“工厂”，把创建者和 class 分离，符合开放封闭原则。

```javascript 
// 工厂
function create(a, b) {
    if (a) {
        return Foo(x)
    }
    if (b) {
        return Foo(x, y)
    }
}

const f1 = create(a, b)
```


## 4.3注意

工厂模式可以拆分为三个：

- 工厂方法模式
- 抽象工厂模式
- 建造者模式

前端用不到这么细致，只需要掌握核心的工厂模式即可。

## 4.4标准的工厂模式

![](https://noteimagebuket.oss-cn-hangzhou.aliyuncs.com/typora/202508280012086.png)

```javascript 
//接口
interface IProduct {
    name: string
    fn1: () => void
    fn2: () => void
}

// 实现IProduct接口
class Product1 implements IProduct { 
    name: string
    constructor(name: string) {
        this.name = name
    }
    fn1() { 
        alert('product1 fn1')
    }
    fn2() { 
        alert('product1 fn2')
    }
}
// 实现IProduct接口
class Product2 implements IProduct { 
    name: string
    constructor(name: string) {
        this.name = name
    }
    fn1() { 
        alert('product2 fn1')
    }
    fn2() { 
        alert('product2 fn2')
    }
}

class Creator { 
    //依赖倒置原则
    create(type: string, name: string): IProduct {
        if (type === 'p1') {
            return new Product1(name)
        }
        if (type === 'p2') {
            return new Product2(name)
        }
        throw new Error('Invalid type')
    }
}
// test
const creator=new Creator()
const p1=creator.create('p1','name1')
const p2=creator.create('p2','name2')
const p3=creator.create('p3','name3')
```


## 4.5简单的工厂模式

![](https://noteimagebuket.oss-cn-hangzhou.aliyuncs.com/typora/202508280012871.png)

```javascript 
class Product { 
    name: string
    constructor(name: string) {
        this.name = name
    }
    fn1() { 
        alert('product fn1')
    }
    fn2() { 
        alert('product fn2')
    }
}

// 工厂
class Creator { 
    create(name: string): Product {
        return new Product(name)
    }
}
// test
const creator=new Creator()
const p1=creator.create('p1')
const p2=creator.create('p2')
const p3=creator.create('p3')

```


## 4.6应用

### 4.6.1jQuery `$('div')`

```react tsx 
// 扩展 window的属性（解决ts警告，因为Window上没有$方法）
declare interface Window { 
    $: (selector: string) => JQuery
}

class JQuery {
    selector: string
    length: number

    constructor(selector: string) {
        const domList = Array.prototype.slice.call(document.querySelectorAll(selector))
        const length = domList.length
        for (let i = 0; i < length; i++) { 
            this[i] = domList[0]
        }

        this.selector = selector
        this.length = length
    }

    append(elem: HTMLElement): JQuery {
        // ...
        return this
    }

    addClass(key: string, value: string): JQuery {
        // ...
        return this
    }

    html(htmlStr: string): JQuery | string { 
        if (htmlStr) {
            // set html
            return this
        } else { 
            // get html
            const html = 'xxx'
            return html
        }
    }
}
// 不用工厂模式
const $div = new JQuery('div')
const $p = new JQuery('p')

// 使用工厂模式
window.$ = (selector) => { 
    return new JQuery(selector)
}
const $div = $('div')
const $p = $('p')

```


做一个对比，如果开放给用户的不是`$`，然后让用户自己去`new JQuery(selector)`，带来的问题：

- 不方便链式操作，如`$('div').append($('#p1')).html()`
- 不宜将构造函数暴露给用户，尽量高内聚、低耦合

### 4.6.2Vue `_createElementVNode`

```react tsx 
<div>
  <span>静态文字</span>
  <span :id="hello" class="bar">{{ msg }}</span>
</div>
```


会编译出很多 `_createXxx` JS 代码。这些就是工厂函数，创建 vnode 。

```react tsx 
export function render(_ctx, _cache, $props, $setup, $data, $options) {
  return (_openBlock(), _createElementBlock("div", null, [
    _createElementVNode("span", null, "静态文字"),
    _createElementVNode("span", {
      id: _ctx.hello,
      class: "bar"
    }, _toDisplayString(_ctx.msg), 9 /* TEXT, PROPS */, ["id"])
  ]))
}
```


### 4.6.3 React `createElement`

在 React 中使用 JSX 语法

```react tsx 
const profile = <div>
  <img src="avatar.png" className="profile" />
  <h3>{[user.firstName, user.lastName].join(' ')}</h3>
</div>
```


这是一种语法糖，编译之后就会是

```javascript 
// 返回 vnode
const profile = React.createElement("div", null,
    React.createElement("img", { src: "avatar.png", className: "profile" }),
    React.createElement("h3", null, [user.firstName, user.lastName].join(" "))
);
```


其实`React.createElement`也是一个工厂，模拟代码

```javascript 
class Vnode(tag, attrs, children) {
    // ...省略内部代码...
}
React.createElement =  function (tag, attrs, children) {
    return new Vnode(tag, attrs, children)
}
```


# 5.单例模式

> 前端用到严格的单例模式并不多，但单例模式的思想到处都有。

单例模式，即对一个 class 只能创建一个实例，即便调用多次。如一个系统的登录框、遮罩层，可能会被很多地方调用，但登录框只初始化一次即可，以后的直接复用。再例如，想 Vuex Redux 这些全局数据存储，全局只能有一个实例，如果有多个，会出错的。

登录框，初始化多次没必要。

```react tsx 
class LoginModal { }

// modal1 和 modal2 功能一样，没必要初始化两次
const modal1 = new LoginModal()
const modal2 = new LoginModal()
```


全局存储，初始化多个实例，会出错。

```react tsx 
class Store { /* get set ... */ }

const store1 = new Store()
store1.set(key, value)

const store2 = new Store()
store2.get(key) // 获取不到
```


## 5.1原理

UML类图：

![](https://noteimagebuket.oss-cn-hangzhou.aliyuncs.com/typora/202508280012720.png)

### 5.1.1使用TS实现

- `static` 静态属性和方法 —— **详细介绍一下，对比“静态xx”和“实例xx”**
- `private` 外部无法直接初始化

```react tsx 
class Singleton {
    // private - 外部无法初始化，就无法在外部使用new
    private constructor() { }

    // static 属性:单例对象
    private static instance: Singleton | null

    // static 方法：获取单例
    static getInstance(): Singleton {
        // 这里也可以写 `this.instance` ，注意和实例方法中 this 的区别！！！
        if (Singleton.instance == null) {
            Singleton.instance = new Singleton()
        }
        return Singleton.instance
    }
}

// const s1 = new Singleton() // 直接初始化会报错
// Singleton.instance // 直接访问 instance 也会报错

// 创建实例
const s1 = Singleton.getInstance()
const s2 = Singleton.getInstance()

console.log(s1 === s2) // true
```


### 5.1.2使用js实现

最常见的方式，使用闭包

```react tsx 
function genGetInstance() {
    let instance // 闭包

    class Singleton {}

    return () => {
        if (instance == null) {
            instance = new Singleton
        }
        return instance
    }
}

const getInstance = genGetInstance()

const s1 = getInstance()
const s2 = getInstance()

console.log(s1 === s2) // true
```


结合模块化语法，会更好一些

```react tsx 
let instance // 闭包

class Singleton {}

// 外部只能 import 这个函数
export default () => {
    if (instance == null) {
        instance = new Singleton
    }
    return instance
}
```


5 大设计原则中，最重要的就是：**开放封闭原则**，对扩展开放，对修改封闭

- 内部封装 getInstance ，内聚，解耦

> 注意：JS 是单线程语言，如果是 Java 等多线程语言，单例模式需要加**线程锁**。

## 5.2应用

一个页面有很多地方调用登录框，使用单例模式

```react tsx 
class LoginForm {
    private state: string = 'hide' // 'hide' / 'show'

    private constructor() {}

    show() {
        if (this.state === 'show') {
            console.log('已经显示了')
            return
        }
        console.log('显示 LoginForm')
        this.state = 'show'
    }

    hide() {
        if (this.state === 'hide') {
            console.log('已经隐藏了')
            return
        }
        console.log('隐藏 LoginForm')
        this.state = 'hide'
    }

    private static instance: LoginForm | null = null
    static getInstance(): LoginForm {
        // 注意这里的 this
        if (this.instance == null) this.instance = new LoginForm()
        return this.instance
    }
}

const loginForm1 = LoginForm.getInstance()
const loginForm2 = LoginForm.getInstance()
```


前端用到严格的单例模式并不多，但单例模式的思想到处都有

- 自定义事件 eventBus 全局只有一个
- Vuex Redux store 全局只有一个

# 6. 观察者模式

# 7. 迭代器模式

# 8.原型模式

# 9.装饰器模式

# 10. 代理模式

# 11. 其他模式

# 12. 实战演练

- `static` 静态属性和方法 —— **详细介绍一下，对比“静态xx”和“实例xx”**
- `private` 外部无法直接初始化
