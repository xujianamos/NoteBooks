# 任务取消机制使用说明

## 概述

本系统实现了一个完整的任务取消机制，当用户删除正在运行的任务时，系统会自动通知任务调度器停止执行该任务。

## 架构设计

### 1. 核心组件

- **EnhancedTaskScheduler**: 增强版任务调度器，支持任务取消
- **TaskCancellationManager**: 任务取消管理器，处理取消请求
- **取消通知机制**: 基于文件系统的跨进程通信

### 2. 工作流程

```
用户删除任务 → 检查任务状态 → 发送取消请求 → 调度器检查取消信号 → 停止任务执行
```

## 主要功能

### 1. 任务取消机制

- **本地取消**: 通过 `asyncio.Event` 实现同一进程内的任务取消
- **跨进程取消**: 通过文件系统实现不同进程间的取消通知
- **取消检查点**: 在任务执行的关键点检查取消信号

### 2. 取消通知系统

- **文件存储**: 取消请求存储在 `/tmp/task_cancellations/` 目录
- **状态管理**: 支持 `pending` 和 `processed` 状态
- **自动清理**: 定期清理过期的取消请求文件

## 使用方法

### 1. 删除正在运行的任务

当用户通过 API 删除任务时，系统会自动：

```python
# 在 delete_task 函数中
if task_detail.status == "running":
    # 发送取消请求
    await cancellation_manager.request_cancellation(
        task_id,
        f"用户删除任务请求 - 用户: {user_info.get('name', 'unknown')}"
    )
    # 等待任务停止
    await asyncio.sleep(2)
```

### 2. 手动取消任务

```python
from app.utils.task_cancellation import cancellation_manager

# 请求取消任务
await cancellation_manager.request_cancellation(
    task_id="your_task_id",
    reason="手动取消请求"
)
```

### 3. 检查取消请求

```python
# 检查是否有取消请求
request = await cancellation_manager.check_cancellation_request(task_id)
if request and request.get("status") == "pending":
    # 处理取消请求
    pass
```

## 配置说明

### 1. 调度器配置

在 `app/core/scheduler_config.py` 中：

```python
# 任务超时时间（秒）
TASK_TIMEOUT: int = int(os.getenv("SCHEDULER_TASK_TIMEOUT", "300"))

# 任务重试次数
MAX_RETRIES: int = int(os.getenv("SCHEDULER_MAX_RETRIES", "3"))

# 重试间隔（秒）
RETRY_INTERVAL: int = int(os.getenv("SCHEDULER_RETRY_INTERVAL", "60"))
```

### 2. 取消通知目录

默认取消通知文件存储在 `/tmp/task_cancellations/`，可以通过环境变量修改：

```python
# 在 TaskCancellationManager 初始化时
notification_dir = os.getenv("TASK_CANCELLATION_DIR", "/tmp/task_cancellations")
```

## 监控和日志

### 1. 调度器统计

调度器会记录以下统计信息：

- 总处理任务数
- 成功任务数
- 失败任务数
- **取消任务数** (新增)

### 2. 日志记录

系统会记录详细的取消操作日志：

```
INFO: 任务 task_123 收到取消请求，停止处理: 用户删除任务请求
INFO: 已发送取消信号给任务: task_123
INFO: 任务 task_123 收到取消信号，停止执行
```

## 测试

### 1. 运行测试脚本

```bash
python test_task_cancellation.py
```

### 2. 测试场景

- 创建取消请求
- 检查取消请求状态
- 标记请求为已处理
- 清理取消请求文件
- 批量处理多个取消请求

## 注意事项

### 1. 文件权限

确保调度器进程有权限读写 `/tmp/task_cancellations/` 目录。

### 2. 磁盘空间

取消请求文件会占用少量磁盘空间，系统会自动清理过期文件。

### 3. 并发安全

取消机制是线程安全的，支持多个进程同时操作。

### 4. 任务状态

被取消的任务状态会更新为 `cancelled`，不会影响其他任务的执行。

## 故障排除

### 1. 任务无法取消

- 检查调度器是否正在运行
- 确认任务确实在运行状态
- 查看日志中的错误信息

### 2. 取消请求文件问题

- 检查目录权限
- 手动清理过期文件
- 重启调度器服务

### 3. 性能影响

- 取消检查点设计为轻量级操作
- 不会显著影响任务执行性能
- 建议定期清理过期文件

## 扩展功能

### 1. Redis 支持

可以扩展为使用 Redis 作为通知机制：

```python
# 替换文件系统为 Redis
class RedisTaskCancellationManager:
    def __init__(self, redis_client):
        self.redis = redis_client
```

### 2. WebSocket 通知

可以添加实时通知功能，通过 WebSocket 向用户推送任务取消状态。

### 3. 批量取消

支持批量取消多个任务的功能。

## 总结

这个任务取消机制提供了完整的解决方案，确保用户删除任务时能够及时停止正在执行的任务，避免资源浪费和潜在的数据不一致问题。系统设计考虑了可靠性、性能和可扩展性，能够满足生产环境的需求。



