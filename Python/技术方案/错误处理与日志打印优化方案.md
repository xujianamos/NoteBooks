# FastAPI 错误处理与日志打印优化方案

## 1. 现状分析

### 1.1 当前问题

通过分析 `app/api/v1/task.py` 和 `app/services/task_service.py` 代码，发现以下问题：

#### API层问题
1. **重复的参数验证**：每个接口都重复检查 `user_info` 和其他参数
2. **相同的异常处理模式**：大量 `try-except` 块处理相同类型的异常
3. **不一致的错误响应**：有些地方返回 `error_response`，有些地方抛出 `HTTPException`
4. **日志记录不统一**：有些地方记录日志，有些地方没有

#### Service层问题
1. **混合的返回类型**：有些函数返回 `Dict`，有些抛出异常，有些返回 `error_response`
2. **重复的用户权限检查**：多个函数都有相同的用户信息验证逻辑
3. **异常处理不统一**：ES异常、HTTP异常、业务异常处理方式不一致
4. **日志级别使用不当**：过多使用 `info` 级别，缺少 `debug` 和 `warning` 的合理使用

### 1.2 具体代码示例

**重复的参数验证**：
```python
# 在多个API接口中重复出现
if not user_info:
    return error_response(message="用户信息不能为空", code=400)
if not task_id:
    return error_response(message="任务ID不能为空", code=400)
```

**不一致的异常处理**：
```python
# 方式1：返回error_response
except Exception as e:
    return error_response(message=f"创建下载任务失败: {str(e)}")

# 方式2：抛出HTTPException
except Exception as e:
    logger.error(f"获取任务详情时发生未知错误: {str(e)}")
    raise HTTPException(status_code=500, detail="服务器内部错误")
```

## 2. 优化方案设计

### 2.1 统一异常处理架构

#### 2.1.1 自定义异常类层次结构

```python
# app/core/exceptions.py
from typing import Optional, Dict, Any
from fastapi import status

class BaseBusinessException(Exception):
    """业务异常基类"""
    def __init__(self, message: str, code: int = 500, details: Optional[Dict[str, Any]] = None):
        self.message = message
        self.code = code
        self.details = details or {}
        super().__init__(message)

class ValidationException(BaseBusinessException):
    """参数验证异常"""
    def __init__(self, message: str, field: Optional[str] = None):
        super().__init__(message, status.HTTP_400_BAD_REQUEST, {"field": field})

class NotFoundException(BaseBusinessException):
    """资源不存在异常"""
    def __init__(self, message: str = "资源不存在", resource_type: Optional[str] = None):
        super().__init__(message, status.HTTP_404_NOT_FOUND, {"resource_type": resource_type})

class PermissionException(BaseBusinessException):
    """权限异常"""
    def __init__(self, message: str = "没有权限访问该资源"):
        super().__init__(message, status.HTTP_403_FORBIDDEN)

class ExternalServiceException(BaseBusinessException):
    """外部服务异常"""
    def __init__(self, message: str, service_name: str):
        super().__init__(message, status.HTTP_503_SERVICE_UNAVAILABLE, {"service": service_name})

class ElasticsearchException(BaseBusinessException):
    """Elasticsearch异常"""
    def __init__(self, message: str, operation: str):
        super().__init__(message, status.HTTP_500_INTERNAL_SERVER_ERROR, {"operation": operation})
```

#### 2.1.2 全局异常处理器

```python
# app/core/exception_handlers.py
from fastapi import Request, HTTPException
from fastapi.responses import JSONResponse
from elasticsearch.exceptions import NotFoundError, ConnectionError, RequestError
from app.core.exceptions import BaseBusinessException
from app.utils.response_formatter import error_response
from app.core.logging_config import get_logger
import traceback

logger = get_logger(__name__)

async def business_exception_handler(request: Request, exc: BaseBusinessException) -> JSONResponse:
    """业务异常处理器"""
    logger.warning(f"业务异常: {exc.message}", extra={
        "exception_type": type(exc).__name__,
        "code": exc.code,
        "details": exc.details,
        "path": request.url.path,
        "method": request.method
    })
    return error_response(message=exc.message, code=exc.code)

async def http_exception_handler(request: Request, exc: HTTPException) -> JSONResponse:
    """HTTP异常处理器"""
    logger.warning(f"HTTP异常: {exc.detail}", extra={
        "status_code": exc.status_code,
        "path": request.url.path,
        "method": request.method
    })
    return error_response(message=str(exc.detail), code=exc.status_code)

async def elasticsearch_exception_handler(request: Request, exc: Exception) -> JSONResponse:
    """Elasticsearch异常处理器"""
    if isinstance(exc, NotFoundError):
        logger.info(f"ES资源未找到: {request.url.path}")
        return error_response(message="资源不存在", code=404)
    elif isinstance(exc, ConnectionError):
        logger.error(f"ES连接失败: {str(exc)}", extra={"path": request.url.path})
        return error_response(message="数据库连接失败", code=503)
    elif isinstance(exc, RequestError):
        logger.error(f"ES请求错误: {str(exc)}", extra={"path": request.url.path})
        return error_response(message="数据查询错误", code=400)
    else:
        logger.error(f"ES未知错误: {str(exc)}", extra={"path": request.url.path})
        return error_response(message="数据库操作失败", code=500)

async def general_exception_handler(request: Request, exc: Exception) -> JSONResponse:
    """通用异常处理器"""
    logger.error(f"未处理异常: {str(exc)}", extra={
        "exception_type": type(exc).__name__,
        "path": request.url.path,
        "method": request.method,
        "traceback": traceback.format_exc()
    })
    return error_response(message="服务器内部错误", code=500)
```

### 2.2 统一日志记录方案

#### 2.2.1 日志装饰器

```python
# app/utils/logging_decorators.py
from functools import wraps
from typing import Callable, Any, Optional
from app.core.logging_config import get_logger
import time
import inspect

def log_api_call(operation: str, log_params: bool = True, log_result: bool = False):
    """API调用日志装饰器"""
    def decorator(func: Callable) -> Callable:
        @wraps(func)
        async def wrapper(*args, **kwargs) -> Any:
            logger = get_logger(func.__module__)
            start_time = time.time()
            
            # 提取用户信息
            user_info = kwargs.get('user_info', {})
            user_id = user_info.get('email', 'unknown') if user_info else 'unknown'
            
            # 记录开始日志
            log_data = {
                "operation": operation,
                "user_id": user_id,
                "function": func.__name__
            }
            
            if log_params:
                # 过滤敏感参数
                safe_kwargs = {k: v for k, v in kwargs.items() 
                             if k not in ['user_info', 'es_client', 'password']}
                log_data["params"] = safe_kwargs
            
            logger.info(f"开始{operation}", extra=log_data)
            
            try:
                result = await func(*args, **kwargs)
                
                # 记录成功日志
                duration = time.time() - start_time
                success_data = {
                    **log_data,
                    "duration_ms": round(duration * 1000, 2),
                    "status": "success"
                }
                
                if log_result and result:
                    # 只记录结果的关键信息
                    if hasattr(result, 'model_dump'):
                        success_data["result_type"] = type(result).__name__
                    elif isinstance(result, dict):
                        success_data["result_keys"] = list(result.keys())
                
                logger.info(f"{operation}成功", extra=success_data)
                return result
                
            except Exception as e:
                # 记录失败日志
                duration = time.time() - start_time
                error_data = {
                    **log_data,
                    "duration_ms": round(duration * 1000, 2),
                    "status": "error",
                    "error_type": type(e).__name__,
                    "error_message": str(e)
                }
                
                logger.error(f"{operation}失败", extra=error_data)
                raise
                
        return wrapper
    return decorator

def log_service_call(operation: str):
    """Service层调用日志装饰器"""
    def decorator(func: Callable) -> Callable:
        @wraps(func)
        async def wrapper(*args, **kwargs) -> Any:
            logger = get_logger(func.__module__)
            
            # 提取关键参数
            sig = inspect.signature(func)
            bound_args = sig.bind(*args, **kwargs)
            bound_args.apply_defaults()
            
            log_data = {
                "operation": operation,
                "function": func.__name__,
                "service": func.__module__.split('.')[-1]
            }
            
            # 记录关键参数
            if 'task_id' in bound_args.arguments:
                log_data["task_id"] = bound_args.arguments['task_id']
            if 'user_info' in bound_args.arguments and bound_args.arguments['user_info']:
                log_data["user_email"] = bound_args.arguments['user_info'].get('email')
            
            logger.debug(f"Service调用: {operation}", extra=log_data)
            
            try:
                result = await func(*args, **kwargs)
                logger.debug(f"Service调用成功: {operation}", extra=log_data)
                return result
            except Exception as e:
                error_data = {
                    **log_data,
                    "error_type": type(e).__name__,
                    "error_message": str(e)
                }
                logger.error(f"Service调用失败: {operation}", extra=error_data)
                raise
                
        return wrapper
    return decorator
```

#### 2.2.2 参数验证装饰器

```python
# app/utils/validation_decorators.py
from functools import wraps
from typing import Callable, Any, List, Optional
from app.core.exceptions import ValidationException

def validate_required_params(*required_params: str):
    """必需参数验证装饰器"""
    def decorator(func: Callable) -> Callable:
        @wraps(func)
        async def wrapper(*args, **kwargs) -> Any:
            for param in required_params:
                if param not in kwargs or not kwargs[param]:
                    raise ValidationException(f"{param}不能为空", field=param)
            return await func(*args, **kwargs)
        return wrapper
    return decorator

def validate_user_permission(func: Callable) -> Callable:
    """用户权限验证装饰器"""
    @wraps(func)
    async def wrapper(*args, **kwargs) -> Any:
        user_info = kwargs.get('user_info')
        if not user_info:
            raise ValidationException("用户信息不能为空", field="user_info")
        if not user_info.get('email'):
            raise ValidationException("用户邮箱信息缺失", field="user_email")
        return await func(*args, **kwargs)
    return wrapper
```

### 2.3 Service层统一返回格式

#### 2.3.1 Service结果包装器

```python
# app/utils/service_result.py
from typing import Any, Optional, Dict, Generic, TypeVar
from pydantic import BaseModel

T = TypeVar('T')

class ServiceResult(BaseModel, Generic[T]):
    """Service层统一返回结果"""
    success: bool
    data: Optional[T] = None
    message: str = ""
    error_code: Optional[str] = None
    
    @classmethod
    def success_result(cls, data: T = None, message: str = "操作成功") -> 'ServiceResult[T]':
        return cls(success=True, data=data, message=message)
    
    @classmethod
    def error_result(cls, message: str, error_code: Optional[str] = None) -> 'ServiceResult[T]':
        return cls(success=False, message=message, error_code=error_code)

def handle_service_exceptions(func: Callable) -> Callable:
    """Service层异常处理装饰器"""
    @wraps(func)
    async def wrapper(*args, **kwargs) -> ServiceResult:
        try:
            result = await func(*args, **kwargs)
            if isinstance(result, ServiceResult):
                return result
            return ServiceResult.success_result(data=result)
        except BaseBusinessException as e:
            # 业务异常直接抛出，让上层处理
            raise
        except Exception as e:
            # 其他异常转换为业务异常
            logger = get_logger(func.__module__)
            logger.error(f"Service层未处理异常: {str(e)}", extra={
                "function": func.__name__,
                "args": str(args)[:200],
                "kwargs": str(kwargs)[:200]
            })
            raise BaseBusinessException(f"服务内部错误: {str(e)}")
    return wrapper
```

## 3. 重构示例

### 3.1 API层重构示例

```python
# app/api/v1/task.py (重构后)
from app.utils.logging_decorators import log_api_call
from app.utils.validation_decorators import validate_required_params, validate_user_permission

@router.post("/", summary="创建下载任务")
@log_api_call("创建下载任务", log_params=True)
@validate_user_permission
@validate_required_params("name", "es_query")
async def create_download_task(
    user_info: dict = Depends(verify_cookie),
    es_query: Dict[str, Any] = Body(..., embed=True),
    name: str = Body(..., description="任务名称"),
    es_client: AsyncElasticsearch = Depends(get_es_client),
):
    """创建下载任务记录，等待定时任务处理器执行。"""
    task = await task_service.create_task(
        es_client, TaskCreate(name=name, input_query=es_query), user_info=user_info
    )
    
    return success_response(
        data={
            "task_id": task.id,
            "status": "pending",
            "message": "任务已创建，等待定时任务处理器执行"
        },
        message="下载任务创建成功",
    )

@router.get("/{task_id}", summary="获取任务详情")
@log_api_call("获取任务详情")
@validate_user_permission
@validate_required_params("task_id")
async def get_task_detail(
    task_id: str,
    user_info: dict = Depends(verify_cookie),
    es_client: AsyncElasticsearch = Depends(get_es_client),
):
    """获取指定任务的详细信息。"""
    response = await task_service.get_task_detail(es_client, task_id=task_id, user_info=user_info)
    return success_response(data=response, message="获取任务详情成功")
```

### 3.2 Service层重构示例

```python
# app/services/task_service.py (重构后)
from app.utils.logging_decorators import log_service_call
from app.utils.validation_decorators import validate_user_permission
from app.core.exceptions import NotFoundException, PermissionException, ElasticsearchException

@log_service_call("获取任务详情")
@validate_user_permission
async def get_task_detail(es_client: AsyncElasticsearch, task_id: str, user_info: dict = None) -> TaskInDB:
    """获取任务详细信息，包括任务状态、进度、创建时间等完整数据。"""
    try:
        response = await es_client.get(index=INDEX_NAME, id=task_id)
    except NotFoundError:
        raise NotFoundException("任务不存在", resource_type="task")
    except Exception as e:
        raise ElasticsearchException(f"查询任务失败: {str(e)}", operation="get_task")

    source = response.get("_source", {})
    if not source:
        raise NotFoundException("任务数据不完整", resource_type="task")
    
    # 权限验证
    task_username = source.get("user_name")
    if not task_username:
        raise ValidationException("任务缺少创建者信息")
    
    if task_username != user_info["name"]:
        raise PermissionException("没有权限访问该任务")
    
    source["id"] = response.get("_id", task_id)
    return TaskInDB.model_validate(source)

@log_service_call("删除任务")
@validate_user_permission
async def delete_task(es_client: AsyncElasticsearch, task_id: str, user_info: dict = None) -> Dict[str, Any]:
    """根据任务ID删除单个任务。"""
    # 先检查任务是否存在和权限
    await get_task_detail(es_client, task_id, user_info)
    
    try:
        await es_client.delete(index=INDEX_NAME, id=task_id)
        return {
            "success": True,
            "task_id": task_id,
            "message": f"任务 {task_id} 已成功删除"
        }
    except Exception as e:
        raise ElasticsearchException(f"删除任务失败: {str(e)}", operation="delete_task")
```

## 4. 配置和集成

### 4.1 在main.py中注册异常处理器

```python
# app/main.py
from fastapi import FastAPI
from app.core.exception_handlers import (
    business_exception_handler,
    http_exception_handler,
    elasticsearch_exception_handler,
    general_exception_handler
)
from app.core.exceptions import BaseBusinessException
from fastapi import HTTPException
from elasticsearch.exceptions import ElasticsearchException

app = FastAPI()

# 注册异常处理器
app.add_exception_handler(BaseBusinessException, business_exception_handler)
app.add_exception_handler(HTTPException, http_exception_handler)
app.add_exception_handler(ElasticsearchException, elasticsearch_exception_handler)
app.add_exception_handler(Exception, general_exception_handler)
```

### 4.2 日志配置优化

```python
# app/core/logging_config.py (增强版)
import logging
import sys
from typing import Dict, Any
from pythonjsonlogger import jsonlogger

class CustomJsonFormatter(jsonlogger.JsonFormatter):
    """自定义JSON日志格式化器"""
    
    def add_fields(self, log_record: Dict[str, Any], record: logging.LogRecord, message_dict: Dict[str, Any]):
        super().add_fields(log_record, record, message_dict)
        
        # 添加自定义字段
        log_record['level'] = record.levelname
        log_record['logger'] = record.name
        log_record['module'] = record.module
        log_record['function'] = record.funcName
        log_record['line'] = record.lineno
        
        # 添加业务相关字段
        if hasattr(record, 'user_id'):
            log_record['user_id'] = record.user_id
        if hasattr(record, 'operation'):
            log_record['operation'] = record.operation
        if hasattr(record, 'duration_ms'):
            log_record['duration_ms'] = record.duration_ms

def setup_logging():
    """设置日志配置"""
    # 创建格式化器
    formatter = CustomJsonFormatter(
        '%(asctime)s %(level)s %(logger)s %(message)s'
    )
    
    # 创建处理器
    handler = logging.StreamHandler(sys.stdout)
    handler.setFormatter(formatter)
    
    # 配置根日志器
    root_logger = logging.getLogger()
    root_logger.setLevel(logging.INFO)
    root_logger.addHandler(handler)
    
    # 设置第三方库日志级别
    logging.getLogger('elasticsearch').setLevel(logging.WARNING)
    logging.getLogger('urllib3').setLevel(logging.WARNING)
```

## 5. 实施建议

### 5.1 分阶段实施

1. **第一阶段**：实现基础异常类和全局异常处理器
2. **第二阶段**：重构Service层，统一返回格式和异常处理
3. **第三阶段**：重构API层，应用装饰器和统一验证
4. **第四阶段**：优化日志配置和监控集成

### 5.2 测试策略

1. **单元测试**：为每个异常类和装饰器编写测试
2. **集成测试**：测试异常处理器的完整流程
3. **性能测试**：确保装饰器不会显著影响性能

### 5.3 监控和告警

1. **错误率监控**：监控各类异常的发生频率
2. **性能监控**：监控API响应时间和Service调用时长
3. **业务监控**：监控关键业务指标（任务创建成功率等）

## 6. 预期收益

1. **代码质量提升**：减少重复代码，提高可维护性
2. **错误处理统一**：统一的异常处理机制，更好的用户体验
3. **日志质量改善**：结构化日志，便于问题排查和监控
4. **开发效率提升**：装饰器简化开发，减少样板代码
5. **系统稳定性**：更好的异常处理和监控能力

通过这套方案，可以显著改善当前代码中存在的错误处理和日志打印问题，提升系统的可维护性和稳定性。