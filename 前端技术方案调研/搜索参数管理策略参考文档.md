# 搜索参数管理策略参考文档

本文档详细介绍了多种搜索参数管理策略，每种策略都有完整的代码实现和适用场景分析。

## 目录

1. [URL参数作为唯一数据源策略](#1-url参数作为唯一数据源策略)
2. [localStorage作为主数据源策略](#2-localstorage作为主数据源策略)
3. [状态机管理策略](#3-状态机管理策略)
4. [事件驱动策略](#4-事件驱动策略)
5. [Context + Reducer策略](#5-context--reducer策略)
6. [Zustand状态管理策略](#6-zustand状态管理策略)
7. [混合策略](#7-混合策略)
8. [策略选择建议](#8-策略选择建议)

---

## 1. URL参数作为唯一数据源策略

### 特点

- URL参数是唯一数据源，确保与服务端参数完全一致
- localStorage作为备份，页面刷新时自动恢复
- 菜单切换时自动同步

### 代码实现

#### Hook实现

```typescript
// src/hooks/useSimpleSearchParams.ts
import { useSearchParams } from '@umijs/max';
import { useCallback, useEffect, useMemo, useState } from 'react';
import { searchConditionStore } from '@/utils/searchValuesStore';
import { filterEmptyValues, objectToSearchParams } from '@/utils/Tool';

interface UseSimpleSearchParamsOptions {
  searchKey: string;
  defaultValues?: Record<string, any>;
}

export const useSimpleSearchParams = (options: UseSimpleSearchParamsOptions) => {
  const { searchKey, defaultValues = { page: 1, pageSize: 20 } } = options;

  const [searchParams, setSearchParams] = useSearchParams();
  const [isInitialized, setIsInitialized] = useState(false);

  /**
   * 从URL参数获取数据 - 这是唯一的数据源
   */
  const searchValues = useMemo(() => {
    const params: Record<string, any> = {};
    for (const [key, value] of searchParams.entries()) {
      params[key] = value;
    }
    const filteredParams = filterEmptyValues(params) as Record<string, any>;
    return { ...defaultValues, ...filteredParams };
  }, [searchParams, defaultValues]);

  /**
   * 更新URL参数（主要方法）
   */
  const updateUrl = useCallback(
    (params: Record<string, any>) => {
      const finalParams = { ...defaultValues, ...params };
      const urlParams = objectToSearchParams(filterEmptyValues(finalParams));
      
      // 更新URL参数
      setSearchParams(urlParams);
      
      // 备份到localStorage
      searchConditionStore.save(searchKey, finalParams);
      
      console.log(`[${searchKey}] 更新URL参数:`, finalParams);
    },
    [defaultValues, setSearchParams, searchKey],
  );

  /**
   * 重置所有参数
   */
  const resetAll = useCallback(() => {
    updateUrl(defaultValues);
  }, [updateUrl, defaultValues]);

  /**
   * 初始化 - 从localStorage恢复参数到URL
   */
  useEffect(() => {
    const urlParams = searchValues;
    const storageParams = searchConditionStore.get(searchKey) || {};

    // 如果URL没有参数，从localStorage恢复
    if (Object.keys(urlParams).length <= Object.keys(defaultValues).length) {
      if (Object.keys(storageParams).length > 0) {
        console.log(`[${searchKey}] 从localStorage恢复参数到URL:`, storageParams);
        updateUrl(storageParams);
      }
    } else {
      // URL有参数，备份到localStorage
      searchConditionStore.save(searchKey, urlParams);
    }

    setIsInitialized(true);
    console.log(`[${searchKey}] 初始化完成，当前参数:`, urlParams);
  }, []); // 只执行一次

  return {
    // 当前搜索条件（从URL读取）
    searchValues,

    // 更新方法
    updateUrl,
    resetAll,

    // 状态
    isInitialized,

    // 原始参数
    searchParams,
    setSearchParams,
  };
};

export default useSimpleSearchParams;
```

#### 页面组件使用

```typescript
// src/modules/Feedback/index.tsx
import useSimpleSearchParams from '@/hooks/useSimpleSearchParams';

const Feedback = () => {
  // 使用简化搜索参数管理 - URL参数作为唯一数据源
  const { searchValues, updateUrl, resetAll, isInitialized } = useSimpleSearchParams({
    searchKey: FEEDBACK_SEARCH_KEY,
    defaultValues: {
      page: 1,
      pageSize: 20,
    },
  });

  const handleTableChange = (pagination: any, filters: any, sorter: any) => {
    // 分页变化时，直接更新URL参数
    const newParams = {
      ...searchValues,
      page: pagination.current,
      pageSize: pagination.pageSize,
    };

    // 更新URL参数（localStorage会自动备份）
    updateUrl(newParams);
  };

  return (
    <div>
      <FeedbackSearch 
        searchValues={searchValues} 
        onSearch={updateUrl} 
        onReset={resetAll} 
      />
      <PGTable
        searchValues={searchValues}
        onChange={handleTableChange}
      />
    </div>
  );
};
```

### 优势

- ✅ 数据一致性最好
- ✅ 逻辑简单清晰
- ✅ 菜单切换自动同步
- ✅ 无重复请求

### 劣势

- ❌ URL可能很长
- ❌ 浏览器历史记录较多

---

## 2. localStorage作为主数据源策略

### 特点

- localStorage是主数据源，页面刷新保持状态
- URL参数作为展示，可选同步
- 性能较好，URL相对简洁

### 代码实现

```typescript
// src/hooks/useLocalStorageFirst.ts
import { useCallback, useEffect, useState } from 'react';
import { useSearchParams } from '@umijs/max';
import { searchConditionStore } from '@/utils/searchValuesStore';
import { filterEmptyValues, objectToSearchParams } from '@/utils/Tool';

interface UseLocalStorageFirstOptions {
  searchKey: string;
  defaultValues?: Record<string, any>;
  syncToUrl?: boolean; // 是否同步到URL
}

export const useLocalStorageFirst = (options: UseLocalStorageFirstOptions) => {
  const { searchKey, defaultValues = { page: 1, pageSize: 20 }, syncToUrl = true } = options;
  
  const [searchParams, setSearchParams] = useSearchParams();
  const [searchValues, setSearchValues] = useState(() => {
    return searchConditionStore.get(searchKey) || defaultValues;
  });
  const [isInitialized, setIsInitialized] = useState(false);

  /**
   * 更新参数
   */
  const updateParams = useCallback(
    (params: Record<string, any>) => {
      const finalParams = { ...defaultValues, ...params };
      
      // 1. 更新localStorage
      searchConditionStore.save(searchKey, finalParams);
      
      // 2. 更新状态
      setSearchValues(finalParams);
      
      // 3. 更新URL（可选）
      if (syncToUrl) {
        setSearchParams(objectToSearchParams(filterEmptyValues(finalParams)));
      }
      
      console.log(`[${searchKey}] 更新参数:`, finalParams);
    },
    [defaultValues, searchKey, syncToUrl, setSearchParams],
  );

  /**
   * 重置参数
   */
  const resetAll = useCallback(() => {
    updateParams(defaultValues);
  }, [updateParams, defaultValues]);

  /**
   * 初始化
   */
  useEffect(() => {
    const urlParams: Record<string, any> = {};
    for (const [key, value] of searchParams.entries()) {
      urlParams[key] = value;
    }

    // 如果URL有参数且localStorage为空，使用URL参数
    if (Object.keys(urlParams).length > 0 && Object.keys(searchValues).length <= Object.keys(defaultValues).length) {
      console.log(`[${searchKey}] 从URL恢复参数:`, urlParams);
      updateParams(urlParams);
    }

    setIsInitialized(true);
  }, []);

  return {
    searchValues,
    updateParams,
    resetAll,
    isInitialized,
  };
};

export default useLocalStorageFirst;
```

### 优势

- ✅ 页面刷新保持状态
- ✅ URL相对简洁
- ✅ 性能较好

### 劣势

- ❌ 菜单切换需要手动同步
- ❌ 数据源不一致风险

---

## 3. 状态机管理策略

### 特点

- 使用状态机管理参数状态
- 可追溯数据来源
- 灵活的策略切换

### 代码实现

```typescript
// src/hooks/useStateMachine.ts
import { useCallback, useEffect, useReducer, useState } from 'react';
import { useSearchParams } from '@umijs/max';
import { searchConditionStore } from '@/utils/searchValuesStore';
import { filterEmptyValues, objectToSearchParams } from '@/utils/Tool';

type DataSource = 'url' | 'localStorage' | 'default' | 'user';

interface SearchState {
  source: DataSource;
  values: Record<string, any>;
  isInitialized: boolean;
}

type SearchAction = 
  | { type: 'SET_FROM_URL'; payload: Record<string, any> }
  | { type: 'SET_FROM_STORAGE'; payload: Record<string, any> }
  | { type: 'UPDATE_PARAMS'; payload: Record<string, any>; source: DataSource }
  | { type: 'INITIALIZE' };

const searchReducer = (state: SearchState, action: SearchAction): SearchState => {
  switch (action.type) {
    case 'SET_FROM_URL':
      return {
        ...state,
        source: 'url',
        values: action.payload,
      };
    case 'SET_FROM_STORAGE':
      return {
        ...state,
        source: 'localStorage',
        values: action.payload,
      };
    case 'UPDATE_PARAMS':
      return {
        ...state,
        source: action.source,
        values: { ...state.values, ...action.payload },
      };
    case 'INITIALIZE':
      return {
        ...state,
        isInitialized: true,
      };
    default:
      return state;
  }
};

interface UseStateMachineOptions {
  searchKey: string;
  defaultValues?: Record<string, any>;
}

export const useStateMachine = (options: UseStateMachineOptions) => {
  const { searchKey, defaultValues = { page: 1, pageSize: 20 } } = options;
  
  const [searchParams, setSearchParams] = useSearchParams();
  const [state, dispatch] = useReducer(searchReducer, {
    source: 'default',
    values: defaultValues,
    isInitialized: false,
  });

  /**
   * 更新参数
   */
  const updateParams = useCallback(
    (params: Record<string, any>, source: DataSource = 'user') => {
      dispatch({ type: 'UPDATE_PARAMS', payload: params, source });
      
      // 根据来源决定更新策略
      switch (source) {
        case 'user':
          // 用户操作：更新URL和localStorage
          setSearchParams(objectToSearchParams(filterEmptyValues(params)));
          searchConditionStore.save(searchKey, params);
          break;
        case 'url':
          // URL变化：只更新localStorage
          searchConditionStore.save(searchKey, params);
          break;
        case 'localStorage':
          // localStorage变化：只更新URL
          setSearchParams(objectToSearchParams(filterEmptyValues(params)));
          break;
      }
    },
    [searchKey, setSearchParams],
  );

  /**
   * 重置参数
   */
  const resetAll = useCallback(() => {
    updateParams(defaultValues, 'user');
  }, [updateParams, defaultValues]);

  /**
   * 初始化
   */
  useEffect(() => {
    const urlParams: Record<string, any> = {};
    for (const [key, value] of searchParams.entries()) {
      urlParams[key] = value;
    }
    const storageParams = searchConditionStore.get(searchKey) || {};

    if (Object.keys(urlParams).length > 0) {
      dispatch({ type: 'SET_FROM_URL', payload: urlParams });
    } else if (Object.keys(storageParams).length > 0) {
      dispatch({ type: 'SET_FROM_STORAGE', payload: storageParams });
    }

    dispatch({ type: 'INITIALIZE' });
  }, []);

  return {
    searchValues: state.values,
    source: state.source,
    updateParams,
    resetAll,
    isInitialized: state.isInitialized,
  };
};

export default useStateMachine;
```

### 优势

- ✅ 状态管理清晰
- ✅ 可追溯数据来源
- ✅ 灵活的策略切换

### 劣势

- ❌ 复杂度较高
- ❌ 学习成本大

---

## 4. 事件驱动策略

### 特点

- 使用事件系统管理参数同步
- 解耦性好
- 易于扩展

### 代码实现

```typescript
// src/hooks/useEventDriven.ts
import { useCallback, useEffect, useState } from 'react';
import { useSearchParams } from '@umijs/max';
import { searchConditionStore } from '@/utils/searchValuesStore';
import { filterEmptyValues, objectToSearchParams } from '@/utils/Tool';

interface UseEventDrivenOptions {
  searchKey: string;
  defaultValues?: Record<string, any>;
}

// 事件类型定义
interface SearchParamsEvent extends CustomEvent {
  detail: {
    searchKey: string;
    params: Record<string, any>;
    source: 'url' | 'localStorage' | 'user';
  };
}

export const useEventDriven = (options: UseEventDrivenOptions) => {
  const { searchKey, defaultValues = { page: 1, pageSize: 20 } } = options;
  
  const [searchParams, setSearchParams] = useSearchParams();
  const [searchValues, setSearchValues] = useState(defaultValues);
  const [isInitialized, setIsInitialized] = useState(false);

  /**
   * 发送事件
   */
  const emitEvent = useCallback(
    (params: Record<string, any>, source: 'url' | 'localStorage' | 'user') => {
      const event = new CustomEvent('searchParamsChange', {
        detail: { searchKey, params, source },
      }) as SearchParamsEvent;
      window.dispatchEvent(event);
    },
    [searchKey],
  );

  /**
   * 更新参数
   */
  const updateParams = useCallback(
    (params: Record<string, any>, source: 'url' | 'localStorage' | 'user' = 'user') => {
      const finalParams = { ...defaultValues, ...params };
      
      // 更新状态
      setSearchValues(finalParams);
      
      // 根据来源决定更新策略
      switch (source) {
        case 'user':
          // 用户操作：更新URL和localStorage
          setSearchParams(objectToSearchParams(filterEmptyValues(finalParams)));
          searchConditionStore.save(searchKey, finalParams);
          break;
        case 'url':
          // URL变化：只更新localStorage
          searchConditionStore.save(searchKey, finalParams);
          break;
        case 'localStorage':
          // localStorage变化：只更新URL
          setSearchParams(objectToSearchParams(filterEmptyValues(finalParams)));
          break;
      }
      
      // 发送事件
      emitEvent(finalParams, source);
    },
    [defaultValues, searchKey, setSearchParams, emitEvent],
  );

  /**
   * 重置参数
   */
  const resetAll = useCallback(() => {
    updateParams(defaultValues, 'user');
  }, [updateParams, defaultValues]);

  /**
   * 监听事件
   */
  useEffect(() => {
    const handleParamsChange = (event: SearchParamsEvent) => {
      if (event.detail.searchKey === searchKey) {
        setSearchValues(event.detail.params);
      }
    };

    window.addEventListener('searchParamsChange', handleParamsChange as EventListener);
    
    return () => {
      window.removeEventListener('searchParamsChange', handleParamsChange as EventListener);
    };
  }, [searchKey]);

  /**
   * 初始化
   */
  useEffect(() => {
    const urlParams: Record<string, any> = {};
    for (const [key, value] of searchParams.entries()) {
      urlParams[key] = value;
    }
    const storageParams = searchConditionStore.get(searchKey) || {};

    if (Object.keys(urlParams).length > 0) {
      updateParams(urlParams, 'url');
    } else if (Object.keys(storageParams).length > 0) {
      updateParams(storageParams, 'localStorage');
    }

    setIsInitialized(true);
  }, []);

  return {
    searchValues,
    updateParams,
    resetAll,
    isInitialized,
  };
};

export default useEventDriven;
```

### 优势

- ✅ 解耦性好
- ✅ 易于扩展
- ✅ 支持多组件通信

### 劣势

- ❌ 调试困难
- ❌ 事件管理复杂

---

## 5. Context + Reducer策略

### 特点

- 使用React Context和useReducer管理全局状态
- 类型安全
- 易于测试

### 代码实现

```typescript
// src/contexts/SearchParamsContext.tsx
import React, { createContext, useContext, useReducer, useCallback, useEffect } from 'react';
import { useSearchParams } from '@umijs/max';
import { searchConditionStore } from '@/utils/searchValuesStore';
import { filterEmptyValues, objectToSearchParams } from '@/utils/Tool';

type DataSource = 'url' | 'localStorage' | 'default' | 'user';

interface SearchParamsState {
  searchValues: Record<string, any>;
  source: DataSource;
  isInitialized: boolean;
}

type SearchParamsAction = 
  | { type: 'SET_FROM_URL'; payload: Record<string, any> }
  | { type: 'SET_FROM_STORAGE'; payload: Record<string, any> }
  | { type: 'UPDATE_PARAMS'; payload: Record<string, any>; source: DataSource }
  | { type: 'INITIALIZE' };

const searchParamsReducer = (state: SearchParamsState, action: SearchParamsAction): SearchParamsState => {
  switch (action.type) {
    case 'SET_FROM_URL':
      return {
        ...state,
        source: 'url',
        searchValues: action.payload,
      };
    case 'SET_FROM_STORAGE':
      return {
        ...state,
        source: 'localStorage',
        searchValues: action.payload,
      };
    case 'UPDATE_PARAMS':
      return {
        ...state,
        source: action.source,
        searchValues: { ...state.searchValues, ...action.payload },
      };
    case 'INITIALIZE':
      return {
        ...state,
        isInitialized: true,
      };
    default:
      return state;
  }
};

interface SearchParamsContextType {
  searchValues: Record<string, any>;
  source: DataSource;
  isInitialized: boolean;
  updateParams: (params: Record<string, any>, source?: DataSource) => void;
  resetAll: () => void;
}

const SearchParamsContext = createContext<SearchParamsContextType | undefined>(undefined);

interface SearchParamsProviderProps {
  children: React.ReactNode;
  searchKey: string;
  defaultValues?: Record<string, any>;
}

export const SearchParamsProvider: React.FC<SearchParamsProviderProps> = ({
  children,
  searchKey,
  defaultValues = { page: 1, pageSize: 20 },
}) => {
  const [searchParams, setSearchParams] = useSearchParams();
  const [state, dispatch] = useReducer(searchParamsReducer, {
    searchValues: defaultValues,
    source: 'default',
    isInitialized: false,
  });

  const updateParams = useCallback(
    (params: Record<string, any>, source: DataSource = 'user') => {
      dispatch({ type: 'UPDATE_PARAMS', payload: params, source });
      
      // 根据来源决定更新策略
      switch (source) {
        case 'user':
          setSearchParams(objectToSearchParams(filterEmptyValues(params)));
          searchConditionStore.save(searchKey, params);
          break;
        case 'url':
          searchConditionStore.save(searchKey, params);
          break;
        case 'localStorage':
          setSearchParams(objectToSearchParams(filterEmptyValues(params)));
          break;
      }
    },
    [searchKey, setSearchParams],
  );

  const resetAll = useCallback(() => {
    updateParams(defaultValues, 'user');
  }, [updateParams, defaultValues]);

  useEffect(() => {
    const urlParams: Record<string, any> = {};
    for (const [key, value] of searchParams.entries()) {
      urlParams[key] = value;
    }
    const storageParams = searchConditionStore.get(searchKey) || {};

    if (Object.keys(urlParams).length > 0) {
      dispatch({ type: 'SET_FROM_URL', payload: urlParams });
    } else if (Object.keys(storageParams).length > 0) {
      dispatch({ type: 'SET_FROM_STORAGE', payload: storageParams });
    }

    dispatch({ type: 'INITIALIZE' });
  }, []);

  return (
    <SearchParamsContext.Provider
      value={{
        searchValues: state.searchValues,
        source: state.source,
        isInitialized: state.isInitialized,
        updateParams,
        resetAll,
      }}
    >
      {children}
    </SearchParamsContext.Provider>
  );
};

export const useSearchParamsContext = () => {
  const context = useContext(SearchParamsContext);
  if (!context) {
    throw new Error('useSearchParamsContext must be used within SearchParamsProvider');
  }
  return context;
};
```

#### 使用方式

```typescript
// src/modules/Feedback/index.tsx
import { SearchParamsProvider, useSearchParamsContext } from '@/contexts/SearchParamsContext';

const FeedbackContent = () => {
  const { searchValues, updateParams, resetAll, isInitialized } = useSearchParamsContext();

  const handleTableChange = (pagination: any) => {
    updateParams({
      ...searchValues,
      page: pagination.current,
      pageSize: pagination.pageSize,
    });
  };

  return (
    <div>
      <FeedbackSearch 
        searchValues={searchValues} 
        onSearch={updateParams} 
        onReset={resetAll} 
      />
      <PGTable
        searchValues={searchValues}
        onChange={handleTableChange}
      />
    </div>
  );
};

const Feedback = () => {
  return (
    <SearchParamsProvider searchKey={FEEDBACK_SEARCH_KEY}>
      <FeedbackContent />
    </SearchParamsProvider>
  );
};
```

### 优势

- ✅ 全局状态管理
- ✅ 类型安全
- ✅ 易于测试

### 劣势

- ❌ 需要Provider包装
- ❌ 可能过度设计

---

## 6. Zustand状态管理策略

### 特点

- 使用Zustand轻量级状态管理
- 无需Provider
- 支持中间件

### 代码实现

```typescript
// src/stores/searchParamsStore.ts
import { create } from 'zustand';
import { subscribeWithSelector } from 'zustand/middleware';
import { searchConditionStore } from '@/utils/searchValuesStore';
import { filterEmptyValues, objectToSearchParams } from '@/utils/Tool';

type DataSource = 'url' | 'localStorage' | 'default' | 'user';

interface SearchParamsState {
  searchValues: Record<string, any>;
  source: DataSource;
  isInitialized: boolean;
  searchKey: string;
  defaultValues: Record<string, any>;
}

interface SearchParamsActions {
  setFromUrl: (params: Record<string, any>) => void;
  setFromStorage: (params: Record<string, any>) => void;
  updateParams: (params: Record<string, any>, source?: DataSource) => void;
  resetAll: () => void;
  initialize: (searchKey: string, defaultValues: Record<string, any>) => Promise<void>;
}

type SearchParamsStore = SearchParamsState & SearchParamsActions;

export const useSearchParamsStore = create<SearchParamsStore>()(
  subscribeWithSelector((set, get) => ({
    searchValues: {},
    source: 'default',
    isInitialized: false,
    searchKey: '',
    defaultValues: {},

    setFromUrl: (params) => set({ searchValues: params, source: 'url' }),
    
    setFromStorage: (params) => set({ searchValues: params, source: 'localStorage' }),
    
    updateParams: (params, source = 'user') => {
      const state = get();
      const finalParams = { ...state.defaultValues, ...params };
      
      set({ searchValues: finalParams, source });
      
      // 根据来源决定更新策略
      switch (source) {
        case 'user':
          // 这里需要外部传入 setSearchParams 函数
          // 或者通过事件系统通知
          searchConditionStore.save(state.searchKey, finalParams);
          break;
        case 'url':
          searchConditionStore.save(state.searchKey, finalParams);
          break;
        case 'localStorage':
          // 这里需要外部传入 setSearchParams 函数
          break;
      }
    },
    
    resetAll: () => {
      const state = get();
      get().updateParams(state.defaultValues, 'user');
    },
    
    initialize: async (searchKey, defaultValues) => {
      set({ searchKey, defaultValues });
      
      // 获取URL参数
      const urlParams = new URLSearchParams(window.location.search);
      const urlParamsObj: Record<string, any> = {};
      for (const [key, value] of urlParams.entries()) {
        urlParamsObj[key] = value;
      }
      
      // 获取localStorage参数
      const storageParams = searchConditionStore.get(searchKey) || {};
      
      if (Object.keys(urlParamsObj).length > 0) {
        set({ searchValues: { ...defaultValues, ...urlParamsObj }, source: 'url', isInitialized: true });
        searchConditionStore.save(searchKey, urlParamsObj);
      } else if (Object.keys(storageParams).length > 0) {
        set({ searchValues: { ...defaultValues, ...storageParams }, source: 'localStorage', isInitialized: true });
      } else {
        set({ searchValues: defaultValues, source: 'default', isInitialized: true });
      }
    },
  }))
);

// Hook封装
export const useSearchParams = (searchKey: string, defaultValues: Record<string, any> = { page: 1, pageSize: 20 }) => {
  const store = useSearchParamsStore();
  
  // 初始化
  useEffect(() => {
    if (!store.isInitialized) {
      store.initialize(searchKey, defaultValues);
    }
  }, [searchKey, defaultValues, store.isInitialized]);
  
  return {
    searchValues: store.searchValues,
    source: store.source,
    isInitialized: store.isInitialized,
    updateParams: store.updateParams,
    resetAll: store.resetAll,
  };
};
```

#### 使用方式

```typescript
// src/modules/Feedback/index.tsx
import { useSearchParams } from '@/stores/searchParamsStore';

const Feedback = () => {
  const { searchValues, updateParams, resetAll, isInitialized } = useSearchParams(
    FEEDBACK_SEARCH_KEY,
    { page: 1, pageSize: 20 }
  );

  const handleTableChange = (pagination: any) => {
    updateParams({
      ...searchValues,
      page: pagination.current,
      pageSize: pagination.pageSize,
    });
  };

  return (
    <div>
      <FeedbackSearch 
        searchValues={searchValues} 
        onSearch={updateParams} 
        onReset={resetAll} 
      />
      <PGTable
        searchValues={searchValues}
        onChange={handleTableChange}
      />
    </div>
  );
};
```

### 优势

- ✅ 轻量级
- ✅ 无需Provider
- ✅ 支持中间件
- ✅ 性能好

### 劣势

- ❌ 需要额外依赖
- ❌ 学习成本

---

## 7. 混合策略

### 特点

- 结合多种策略的优势
- 灵活性高
- 可扩展性强

### 代码实现

```typescript
// src/hooks/useHybridSearchParams.ts
import { useCallback, useEffect, useMemo, useState } from 'react';
import { useSearchParams } from '@umijs/max';
import { searchConditionStore } from '@/utils/searchValuesStore';
import { filterEmptyValues, objectToSearchParams } from '@/utils/Tool';

type DataSource = 'url' | 'localStorage' | 'default' | 'user';

interface UseHybridSearchParamsOptions {
  searchKey: string;
  defaultValues?: Record<string, any>;
  strategy?: 'url-first' | 'storage-first' | 'hybrid';
  syncToUrl?: boolean;
  syncToStorage?: boolean;
}

export const useHybridSearchParams = (options: UseHybridSearchParamsOptions) => {
  const {
    searchKey,
    defaultValues = { page: 1, pageSize: 20 },
    strategy = 'hybrid',
    syncToUrl = true,
    syncToStorage = true,
  } = options;

  const [searchParams, setSearchParams] = useSearchParams();
  const [isInitialized, setIsInitialized] = useState(false);
  const [dataSource, setDataSource] = useState<DataSource>('default');

  // 1. URL参数作为主要数据源
  const urlParams = useMemo(() => {
    const params: Record<string, any> = {};
    for (const [key, value] of searchParams.entries()) {
      params[key] = value;
    }
    return filterEmptyValues(params) as Record<string, any>;
  }, [searchParams]);

  // 2. localStorage作为备份
  const storageParams = useMemo(() => {
    return searchConditionStore.get(searchKey) || {};
  }, [searchKey]);

  // 3. 状态机管理初始化逻辑
  const [initState, setInitState] = useState<'pending' | 'url' | 'storage' | 'default'>('pending');

  // 4. 事件驱动参数更新
  const updateParams = useCallback(
    (params: Record<string, any>, source: DataSource = 'user') => {
      const finalParams = { ...defaultValues, ...params };
      
      // 根据来源决定更新策略
      switch (source) {
        case 'user':
          if (syncToUrl) {
            setSearchParams(objectToSearchParams(filterEmptyValues(finalParams)));
          }
          if (syncToStorage) {
            searchConditionStore.save(searchKey, finalParams);
          }
          setDataSource('user');
          break;
        case 'url':
          if (syncToStorage) {
            searchConditionStore.save(searchKey, finalParams);
          }
          setDataSource('url');
          break;
        case 'localStorage':
          if (syncToUrl) {
            setSearchParams(objectToSearchParams(filterEmptyValues(finalParams)));
          }
          setDataSource('localStorage');
          break;
      }
      
      // 发送事件通知其他组件
      const event = new CustomEvent('searchParamsChange', {
        detail: { searchKey, params: finalParams, source },
      });
      window.dispatchEvent(event);
    },
    [defaultValues, searchKey, syncToUrl, syncToStorage, setSearchParams],
  );

  const resetAll = useCallback(() => {
    updateParams(defaultValues, 'user');
  }, [updateParams, defaultValues]);

  // 5. 初始化逻辑
  useEffect(() => {
    const initialize = () => {
      switch (strategy) {
        case 'url-first':
          if (Object.keys(urlParams).length > 0) {
            setInitState('url');
            updateParams(urlParams, 'url');
          } else if (Object.keys(storageParams).length > 0) {
            setInitState('storage');
            updateParams(storageParams, 'localStorage');
          } else {
            setInitState('default');
            updateParams(defaultValues, 'user');
          }
          break;
          
        case 'storage-first':
          if (Object.keys(storageParams).length > 0) {
            setInitState('storage');
            updateParams(storageParams, 'localStorage');
          } else if (Object.keys(urlParams).length > 0) {
            setInitState('url');
            updateParams(urlParams, 'url');
          } else {
            setInitState('default');
            updateParams(defaultValues, 'user');
          }
          break;
          
        case 'hybrid':
        default:
          if (Object.keys(urlParams).length > 0) {
            setInitState('url');
            updateParams(urlParams, 'url');
          } else if (Object.keys(storageParams).length > 0) {
            setInitState('storage');
            updateParams(storageParams, 'localStorage');
          } else {
            setInitState('default');
            updateParams(defaultValues, 'user');
          }
          break;
      }
      
      setIsInitialized(true);
    };

    initialize();
  }, []);

  // 6. 监听外部变化
  useEffect(() => {
    const handleExternalChange = (event: CustomEvent) => {
      if (event.detail.searchKey === searchKey) {
        // 外部参数变化，同步到当前组件
        updateParams(event.detail.params, event.detail.source);
      }
    };

    window.addEventListener('searchParamsChange', handleExternalChange as EventListener);
    
    return () => {
      window.removeEventListener('searchParamsChange', handleExternalChange as EventListener);
    };
  }, [searchKey, updateParams]);

  return {
    searchValues: { ...defaultValues, ...urlParams },
    dataSource,
    initState,
    updateParams,
    resetAll,
    isInitialized,
  };
};

export default useHybridSearchParams;
```

### 优势

- ✅ 灵活性高
- ✅ 可扩展性强
- ✅ 结合多种策略优势

### 劣势

- ❌ 复杂度较高
- ❌ 配置选项多

---

## 8. 策略选择建议

| 场景           | 推荐策略                 | 理由                  |
| -------------- | ------------------------ | --------------------- |
| **简单项目**   | URL参数作为唯一数据源    | 逻辑简单，维护成本低  |
| **复杂项目**   | 混合策略                 | 灵活性高，可扩展性强  |
| **性能要求高** | localStorage作为主数据源 | 减少URL操作，性能更好 |
| **团队协作**   | Context + Reducer        | 类型安全，易于维护    |
| **大型应用**   | Zustand状态管理          | 轻量级，支持中间件    |
| **需要解耦**   | 事件驱动策略             | 组件间解耦，易于扩展  |

## 总结

每种策略都有其适用场景，选择时需要考虑：

1. **项目复杂度** - 简单项目选择简单策略
2. **团队规模** - 大团队选择类型安全的策略
3. **性能要求** - 高性能要求选择轻量级策略
4. **维护成本** - 考虑长期维护的便利性
5. **扩展性** - 考虑未来功能扩展的需求

建议从简单的策略开始，随着项目复杂度增加逐步升级到更复杂的策略。